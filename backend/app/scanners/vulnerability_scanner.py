import asyncio
import json
from typing import Dict, Any
import subprocess
import os
from .base_scanner import BaseScanner

class VulnerabilityScanner(BaseScanner):
    def __init__(self, target: str, options: Dict[str, Any] = None):
        super().__init__(target, options)
        self.scan_type = options.get('scan_type', 'quick')
        self.zap_path = options.get('zap_path', '/zap/zap.sh')
        self.report_path = options.get('report_path', '/tmp/zap-report.json')

    async def scan(self) -> Dict[str, Any]:
        try:
            self.update_status("running")
            
            # Définir les options ZAP selon le type de scan
            zap_options = {
                'quick': '--quick-scan',
                'full': '--full-scan',
                'api': '--api-scan',
                'custom': '--custom-scan'
            }.get(self.scan_type, '--quick-scan')

            # Construire la commande ZAP
            cmd = [
                self.zap_path,
                zap_options,
                '-t', self.target,
                '-r', self.report_path,
                '-J',  # Format JSON
                '-d'   # Mode daemon
            ]
            
            # Exécuter ZAP
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode != 0:
                self.add_error(f"ZAP error: {stderr.decode()}")
                self.update_status("failed")
                return self.results

            # Lire et parser le rapport JSON
            try:
                with open(self.report_path, 'r') as f:
                    zap_results = json.load(f)

                # Formater les résultats
                scan_results = {
                    "summary": {
                        "total_alerts": len(zap_results.get("alerts", [])),
                        "risk_levels": {
                            "high": 0,
                            "medium": 0,
                            "low": 0,
                            "informational": 0
                        }
                    },
                    "alerts": []
                }

                for alert in zap_results.get("alerts", []):
                    risk = alert.get("risk", "informational").lower()
                    scan_results["summary"]["risk_levels"][risk] += 1
                    
                    alert_data = {
                        "name": alert.get("name"),
                        "risk": risk,
                        "description": alert.get("description"),
                        "solution": alert.get("solution"),
                        "url": alert.get("url"),
                        "evidence": alert.get("evidence")
                    }
                    scan_results["alerts"].append(alert_data)

                self.results["results"] = scan_results
                self.update_status("completed")

                # Nettoyer le fichier de rapport
                if os.path.exists(self.report_path):
                    os.remove(self.report_path)

            except Exception as e:
                self.add_error(f"Error parsing ZAP results: {str(e)}")
                self.update_status("failed")

        except Exception as e:
            self.add_error(f"Scan error: {str(e)}")
            self.update_status("failed")

        return self.results 